- **Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.**
  - **기본키(Primary Key)**
    - 테이블에서 각 레코드를 고유하게 식별하는 속성
    - 유일성과 최소성을 만족해야 합니다. 
    - NULL 값을 가질 수 없습니다. 
    - 테이블당 하나만 존재할 수 있습니다. 
  - **후보키(Candidate Key)**
    - 기본키가 될 수 있는 속성들의 집합입니다. 
    - 유일성과 최소성을 만족합니다. 
    - 여러 개가 존재할 수 있으며, 그 중 하나가 기본키로 선택됩니다. 
  - **슈퍼키(Super Key)**
    - 테이블에서 각 레코드를 고유하게 식별할 수 있는 속성 또는 속성들의 집합입니다. 
    - 유일성은 만족하지만, 최소성은 만족하지 않을 수 있습니다. 
  - **외래키(Foreign Key)**
    - 다른 테이블의 기본키를 참조하는 속성입니다. 
    - 테이블 간의 관계를 정의하고 데이터의 일관성을 유지하는 데 사용됩니다. 
  - **대체키(Alternate Key)**
    - 후보키 중에서 기본키로 선택되지 않은 나머지 키들
-----
- **기본키는 수정이 가능한가요?**
  - 기본키가 테이블에서 각 행을 고유하게 식별하는 역할을 하며, 다른 테이블에서 외래키로 참조될 가능성이 높기 때문에 **원칙적으로 수정이 권장되지는 않습니다.**
  - 만약 불가피하게 기본키를 변경해야 한다면, 다음과 같은 절차를 따라야 합니다.
    1) 외래키 제약 조건을 일시적으로 비활성화
    2) 참조된 모든 외래키 값을 새로운 값으로 업데이트
    3) 기본키 값을 업데이트
    4) 외래키 제약 조건을 다시 활성화
-----
- **사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?**
  - MySQL은 기본키가 없는 경우 이를 대체할 방법을 마련하기 때문에 기본키 없는 테이블 생성을 
    - 제공하지만, **데이터 무결성 측면에서는 권장되지 않습니다.** 
  - UNIQUE NOT NULL 제약 조건이 있는 첫 번째 컬럼을 기본키로 사용할 수 있습니다. 
    - 테이블에 UNIQUE NOT NULL 속성을 가진 컬럼이 있다면, MySQL은 이를 내부적으로 기본키처럼 사용할 수 있습니다.
  - 내부적으로 MySQL은 숨겨진 **자동 증가 컬럼** 을 생성할 수 있습니다. 이 컬럼은 레코드를 고유하게 식별하는 데 사용되지만, 사용자에게는 보이지 않습니다. 
  - 일부 MySQL 엔진(예: InnoDB)은 기본키가 없는 경우 **내부적으로 숨겨진 6바이트 크기의 행 ID** 를 생성합니다.
-----
- **외래키 값은 NULL이 들어올 수 있나요?** 
  - 외래키 값은 NULL이 될 수 있습니다. 그 의미는 해당 값이 특정 행을 참조하지 않는다는 의미로 해석할 수 있습니다. 
    - **선택적 관계** 를 표현할 때 (예: 모든 직원이 부서를 가지지 않을 수 있음)
    - 데이터가 아직 **완전하지 않은 경우** 
    - **일대다 관계** 에서 **'없음'** 을 표현해야 할 때 
  - 단, 외래키에 NULL을 허용할지 여부는 비즈니스 로직과 데이터 모델에 따라 결정해야 합니다.
-----
- **어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?**
  - UNIQUE 제약 조건이 있는 컬럼은 자동으로 인덱스가 생성되므로, 해당 컬럼을 이용한 **검색 성능* *이 일반 컬럼보다 향상됩니다.
  - 즉, 해당 컬럼에 대해 **WHERE 조건** 을 걸거나 **JOIN** 에 활용할 경우 탐색 속도가 빨라질 수 있습니다.
    - 인덱스를 사용하면 데이터 조회 시 전체 테이블을 탐색할 필요 없이 **B-Tree** 또는 다른 인덱스 구조를 활용해 효율적으로 검색할 수 있습니다. 
    - 특히, **유일한 값을 보장** 하기 때문에 **중복 검사에 최적화** 되어 있습니다.
  - 그러나, 데이터 삽입/수정 시 중복 여부를 검사해야 하므로 추가적인 비용이 발생할 수 있습니다. 
    - 삽입 성능이 저하될 수 있으며, 인덱스가 많아지면 쓰기 연산(INSERT, UPDATE, DELETE) 성능이 저하될 수도 있습니다.