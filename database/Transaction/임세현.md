## 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.
트랜잭션 : 더 이상 분할이 불가능한 업무 처리의 단위(여러 개의 연산이 포함될 수 있음)

- 원자성 (Atomicity)
    - 트랜잭션이 모두 db에 반영되거나, 아예 반영되지 않아야 한다
    - 트랜잭션의 일부분만 데이터베이스에 반영되면 안된다
- 일관성 (Consistency)
    - 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다.
    - 트랜잭션 도중 db가 변경되더라도, 처음에 트랜잭션을 진행하기 위해 참조한 db로 진행되어야 한다.
- 독립성 (Isolation)
    - 둘 이상의 트랜잭션이 실행되더라도, 각자의 트랜잭션의 연산에 끼어들 수 없다.
    - 하나의 특정 트랜잭션이 완료될 때 까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.
- 영구성 (Durability)
    - 트랜잭션이 성공적으로 완료되면, 결과는 영구적으로 반영되어야 한다.

## ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요? (수정 필요)
트랜잭션이 COMMIT된 후에도 데이터가 영구적으로 유지되어야 하는 성질을 의미합니다.
DBMS는 다음과 같은 방법으로 Durability를 보장합니다.
1. Write-Ahead Logging (WAL)
PostgreSQL과 Oracle에서 사용하는 방법.
변경 사항을 먼저 로그(REDO Log)에 기록한 후, 실제 데이터를 변경하는 방식.
장애 발생 시 WAL 로그를 사용하여 복구 가능.
2. Redo Log (MySQL InnoDB)
MySQL InnoDB는 Redo Log를 사용하여 트랜잭션 커밋을 보장.
데이터 변경을 Redo Log에 먼저 기록한 후, 실제 데이터를 저장.
장애 발생 시 Redo Log를 이용해 복구 가능.
3. Checkpointing
WAL 또는 Redo Log에 저장된 데이터를 주기적으로 디스크에 반영하여, 로그가 너무 커지지 않도록 관리.

## 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?

## 읽기에는 트랜잭션을 걸지 않아도 될까요?
읽기 전용 쿼리는 트랜잭션을 걸지 않아도 무방하지만, 일관성이 중요하다면 트랜잭션을 사용해야 함.
SELECT 문이 실행되는 동안 다른 트랜잭션이 데이터를 변경하면 예상과 다른 데이터가 반환될 수 있음.

PostgreSQL: REPEATABLE READ 또는 SERIALIZABLE 수준으로 설정하면 트랜잭션이 유지되는 동안 동일한 데이터를 조회 가능.
MySQL: READ COMMITTED 또는 REPEATABLE READ를 사용하여 일관성 보장.

## PostgreSQL이 트랜잭션을 처리하는 방식과 MySQL의 트랜잭션 처리 방식은 어떻게 다른가요?(으아아아)


## 트랜잭션 격리 레벨에 대해 설명해 주세요.
동시에 여러 트랜잭션이 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정 

1. **READ UNCOMMITTED**
    - 각 트랜잭션에서 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있음
    - 사용하지 않는 것을 권장
    - DIRTY READ 발생
        - DIRTY READ : 트랜잭션이 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상
2. **READ COMMITTED**
    - COMMIT이 된 데이터만 읽음
    - 기본적으로 사용
    - NON-REPEATABLE READ 발생
        - NON-REPEATABLE READ : 하나의 트랜잭션 내에서 동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야 한다는 REPEATABLE READ 정합성에 어긋나는 것
3. **REPEATABLE READ**
    - 자신의 트랜잭션이 생성되기 이전의 트랜잭션에서 COMMIT 이 된 데이터만 읽음
    - MySQL과 MariaDB가 기본으로 사용
    - PHANTOM READ 발생
        - PHANTOM READ : 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상
4. **SERIALIZABLE** 
    - 가장 단순하지만 엄격
    - 데이터를 접근할 때, 항상 Lock을 걸고 데이터를 조회
    - 성능 이슈


## 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
PostgreSQL, Oracle은 모든 격리 수준을 지원.
**MySQL (InnoDB)**는 Serializable을 지원하지만, 성능 저하 때문에 잘 사용되지 않음.
일부 DBMS에서는 Read Uncommitted가 지원되지 않거나, 기본적으로 Read Committed만 제공.

## 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.\
1. Undo 영역
롤백을 위해 변경 전 데이터를 저장하는 공간.
MVCC에서 이전 데이터를 유지하여 트랜잭션 격리 수준을 구현할 때 사용됨.
2. Redo 영역
변경된 데이터를 디스크에 적용하기 전에 로그를 저장하는 영역.
장애 발생 시 데이터 복구를 위해 사용됨.

## 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?!

트랜잭션 관리(transaction manager): 트랜잭션을 스케줄링하고 데이터베이스 상태의 논리적 일관성 보장.

잠금 관리(lock manager): 트랜잭션에서 접근하는 데이터베이스 객체에 대한 잠금을 제어. 동시 수행 작업이 물리적 데이터 무결성을 침해하지 않도록 함.
=> 트랜잭션과 잠금 매니저는 동시성 제어. 논리적 물리적 데이터 무결성을 보장하고, 동시 수행 작업의 효율적 수행을 담당.

엑세스 메서드(access method): 디스크에 저장된 데이터에 대한 접근 및 저장 방식을 정의. 힙 파일/B-트리/LSM 트리 등의 자료구조 사용.

버퍼 매니저(buffer manager): 데이터 페이지를 메모리에 캐시.

복구 매니저(recovery manager): 로그를 유지 관리하고 장애 발생 시 시스템을 복구.