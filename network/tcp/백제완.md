## TCP와 UDP의 차이에 대해 설명해 주세요.
### TCP (Transmission Control Protocol)
- **연결 지향**
  - 데이터를 전송하기 전에 반드시 3-Way Handshake 과정을 거쳐 연결을 확립
- **신뢰성 보장**
  - 전송한 데이터에 대해 ACK(응답)를 받고, 손실된 패킷은 재전송하는 메커니즘을 통해 데이터가 순서대로, 완전하게 전달
- **흐름 제어 및 혼잡 제어**
  - 송신측과 수신측 간의 데이터 전송 속도를 조절하여 네트워크의 안정성을 유지
- **헤더가 상대적으로 크고 복잡**
  - 여러 제어 정보(시퀀스 번호, ACK 번호, 윈도우 크기, 체크섬 등)를 포함

### UDP (User Datagram Protocol)
- **비연결 지향**
  - 연결 설정 과정 없이 데이터를 바로 전송함 
- **신뢰성 미보장**
  - 데이터의 순서, 완전성, 오류 정정에 대한 보장이 없으며, 단순히 패킷 단위로 전송
- **헤더가 간단하고 오버헤드가 적음**
  - 빠른 전송이 요구되는 실시간 처리에 유리
 
|종류|TCP|UDP|
|--|--|--|
|연결 방식|연결형 서비스|비연결형 서비스|
|패킷 교환|가상 회선 방식|데이터그램 방식|
|전송 순서 보장|보장함|보장하지 않음|
|신뢰성|높음|낮음|
|전송 속도|느림|빠름|

## Checksum이 무엇인가요? TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?

### Checksum
- 전송된 데이터가 전송 과정에서 변질(비트 에러 등)되었는지 검증하기 위한 값
- 송신측에서 데이터의 모든 바이트를 일정한 방식으로 합산하여 체크섬 값을 계산하고, 수신측에서는 동일한 방식으로 계산하여 비교함
- 오류 감지를 위한 기법이지, 오류를 정정하는 기능은 없음
  
### TCP와 UDP 모두 Checksum을 사용
- TCP 헤더에는 체크섬 필드가 포함되어 있어, 데이터와 헤더의 오류를 검출
- UDP 역시 체크섬 필드를 가지고 있으며, IPv4에서는 옵션으로 사용될 수 있으나, IPv6에서는 필수로 적용됨

## 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
> Checksum은 오류 감지 용도
- 데이터 전송 중에 오류가 발생했는지 확인할 수는 있지만, 오류를 정정하는 기능은 제공하지 않음
- 오류가 감지되면, TCP의 경우 해당 패킷을 폐기하고 재전송을 요구함
- UDP의 경우 오류 검출 후 특별한 정정 메커니즘이 없으므로, 상위 계층에서 별도의 처리가 필요함

## TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
- **3-Way Handshake**
  - 데이터를 전송하기 전, 클라이언트와 서버 간에 3번의 패킷 교환을 통해 연결을 확립 
- **시퀀스 번호와 ACK**
  - 각 패킷에 시퀀스 번호를 부여하여 데이터의 순서를 확인
  - 수신측은 정상적으로 수신한 데이터에 대해 ACK(응답)를 보내어 송신측이 재전송 여부를 판단
- **재전송 메커니즘**
  - 일정 시간 동안 ACK가 도착하지 않으면 패킷을 재전송하여 손실된 데이터가 복구됨
- **흐름 제어** &rarr; `Sliding Window`
  - 수신측의 버퍼 상황(윈도우 크기)을 고려하여 송신측이 전송하는 데이터 양을 조절
- **혼잡 제어**
  - 네트워크 상태에 따라 전송 속도를 동적으로 조절함으로써, 과도한 데이터 전송으로 인한 혼잡을 완화
## 왜 HTTP는 TCP를 사용하나요?
> TCP는 데이터 전송 중 오류를 검출하고 수정하는 기능을 제공하여 데이터가 정확히 도착하도록 보장
- HTTP는 웹 페이지나 파일 등의 데이터를 전송하는데, 데이터의 순서와 완전성이 매우 중요함
- TCP의 오류 검출, 재전송, 흐름/혼잡 제어 등의 기능 덕분에 HTTP 데이터가 안정적으로 전달됨

## 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
> HTTP/3은 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 QUIC(Quick UDP Internet Connection)을 사용하여 통신하는 프로토콜

![gcp-cloud-cdn-performance](https://github.com/user-attachments/assets/9b7910e2-47dd-4273-bf6f-93de96b8cc92)

- HTTP/3의 기반 – QUIC 프로토콜
  - HTTP/3는 QUIC이라는 새로운 전송 프로토콜을 사용하며, 이는 UDP 위에서 동작함
  - QUIC은 UDP의 단순함을 유지하면서도, TCP가 제공하는 신뢰성, 암호화, 혼잡 제어, 다중 스트림 전송 등의 기능을 사용자 수준에서 구현함

- UDP의 문제 해결 여부
  > UDP 자체가 변경된 것은 아니지만, QUIC을 통해 UDP의 단점을 보완하여 TCP 수준 이상의 신뢰성을 제공함
  - 전통적인 UDP는 신뢰성, 순서 보장, 흐름/혼잡 제어 기능이 없지만, QUIC 계층에서 이러한 문제들을 해결하여 연결 수립 지연을 줄이고(0-RTT 연결 재개) 패킷 손실에 따른 빠른 복구와 혼잡 제어를 구현

## 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
- **DNS 및 Alt-Svc 헤더**
  - 서버는 DNS 레코드나 HTTP 응답 헤더(Alt-Svc)를 통해 지원하는 프로토콜(예: HTTP/3 지원 여부)을 브라우저에 알림
- ALPN (Application-Layer Protocol Negotiation)

## TCP의 흐름제어 동작을 TCP 헤더의 필드를 사용하여 설명합니다
### 3-Way Handshake에 대해 설명해 주세요.
![image](https://github.com/user-attachments/assets/f4f26217-52e9-4b59-81c2-5d306a5d6cd7)
1. **SYN (Synchronize)**
     - 클라이언트가 연결 요청을 위해 SYN 패킷을 보내며, 자신의 초기 시퀀스 번호(ISN)를 설정하여 전송
3. **SYN-ACK (Synchronize-Acknowledgement)**
    - 서버가 클라이언트의 SYN 패킷을 수신하면,
      - 자신의 초기 시퀀스 번호를 포함한 SYN 패킷과
      - 클라이언트의 시퀀스 번호에 대한 ACK를 결합한 SYN-ACK 패킷을 전송
3. **ACK (Acknowledgement)**
    - 클라이언트가 서버의 SYN-ACK 패킷을 수신하고,
    - 서버의 시퀀스 번호에 대한 ACK를 포함하는 ACK 패킷을 보내며 연결이 확립됨

### 4-Way Handshake에 대해 설명해 주세요.
1. **FIN 전송**
    - 연결 종료를 원하는 쪽(예: 클라이언트)이 FIN 패킷을 보내어 데이터 전송 종료 의사를 전달
2. **ACK 전송**
    - 상대측(예: 서버)이 FIN 패킷을 수신하고, 이를 확인하는 ACK 패킷을 전송
    - 이 시점에서 연결은 half-close (절반 종료) 상태가 됨
3. **FIN 전송 (상대측)**
    - 서버도 데이터 전송을 종료하기 위해 자신의 FIN 패킷을 전송
4. **ACK 전송 (최종)**
    - 클라이언트가 서버의 FIN 패킷에 대해 ACK를 보내며, 최종적으로 연결이 완전히 종료됨

## TCP의 혼잡제어가 어떻게 동작하는지, 송신단에서 수행하는 두가지 핵심적인 기능을 사용하여 설명합니다.
> 혼잡 제어는 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로를 방지하는 기
### 슬로우 스타트 (Slow Start)

### 혼잡 회피 (Congestion Avoidance)

## TCP에서 두 호스트가 동시에 연결을 시도하면(동시에 SYN요청을 날리는 상황), 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?
> 동시 개시 (Simultaneous Open)

## SYN Flooding 에 대해 설명해 주세요.(개념만)
> 공격자가 대량의 SYN 패킷을 보내 서버의 연결 대기 큐를 빠르게 소진시켜, 정상적인 연결 요청을 처리하지 못하도록 만드는 서비스 거부(DoS) 공격의 한 형태
> 연결 수립 과정에서의 자원 할당 문제를 악용하는 공격 기법

## 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?(추가로 학습하고자 하는사람만)
> 기존의 3-Way Handshake 과정 없이, 이전 연결의 정보를 재사용하여 즉시 데이터 전송을 시작할 수 있는 기술

